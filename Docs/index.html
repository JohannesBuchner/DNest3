<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=ISO-8859-1"
      http-equiv="Content-Type">
    <title>DNest Documentation</title>
  </head>
  <body style=" color: rgb(0, 0, 0); background-color: rgb(255, 255,
    255);" alink="#EE0000" link="#0000EE" vlink="#551A8B">
    <h1 style="background-color: rgb(255, 255, 255);">DNest</h1>
    DNest is a C++ implementation of Diffusive Nested Sampling, a
    powerful Markov Chain Monte Carlo (MCMC) algorithm that is primarily
    useful for solving Bayesian Inference problems. If you find DNest
    useful, please cite the following <a
      href="http://arxiv.org/abs/0912.2380">paper</a>:<br>
    <br>
    <span style="font-style: italic;">Diffusive Nested Sampling</span><br>
    Brendon J. Brewer, Livia B. P&aacute;rtay, G&aacute;bor
    Cs&aacute;nyi, Statistics and Computing, 2011, 21, 4, 649-656.<br>
    <br>
    DNest is (c) 2009, 2010, 2011, 2012 <a
      href="http://web.physics.ucsb.edu/%7Ebrewer/">Brendon J. Brewer</a>
    and is distributed under the terms of the <a
      href="http://en.wikipedia.org/wiki/GPL">GNU General Public Licence</a>,
    version <span style="text-decoration: underline;"></span>3. Please
    see the LICENCE file for details.<br>
    <h3>Installation</h3>
    Please note that I have only ever compiled DNest on GNU/Linux, using
    the GNU C++ compiler. However, I expect it to be straightforward to
    compile it on any other Unix-like OS such as Mac OS X or FreeBSD. It
    should be possible, albeit probably more tricky, to compile DNest on
    Microsoft Windows. If you want to try, the&nbsp;<a
      href="http://www.mingw.org/">MinGW</a> compiler is probably your
    best bet. I'd be interested to hear from anyone who has tried this.
    I would also be interested to hear if anyone has compiled DNest with
    a different compiler, such as the Intel C++ compiler.<br>
    <h3>Dependencies<br>
    </h3>
    DNest requires some other software to be installed on your system.
    Installing these should be quite straightforward.&nbsp; I highly
    recommend obtaining these programs from your OS's package manager,
    rather than installing them from source. Note that some OSs split up
    packages into binaries and "development" packages, with a -dev (e.g.
    in Debian or Ubuntu) or -devel suffix (e.g. Fedora). You will need
    both.<br>
    <br>
    Here's what you will need to have installed:<br>
    <br>
    * <a href="http://www.gnu.org/software/gsl/">The GNU Scientific
      Library</a><br>
    * <a href="http://www.boost.org/">Boost C++ Libraries</a><br>
    * <a href="http://www.python.org/">Python 2</a> + <a
      href="http://numpy.scipy.org/">NumPy</a> + <a
      href="matplotlib.sourceforge.net">matplotlib</a><br>
    <br>
    DNest uses GSL's random number generator, and uses Boost to handle
    multithreading (for improved performance on multi-core CPUs) and
    also to handle the command line options. Python, NumPy and
    matplotlib are used for the postprocessing script (<span
      style="font-family: monospace;">showresults.py</span>) for
    plotting purposes.<br>
    <h3>Compiling<br>
    </h3>
    To compile DNest, simply run<br>
    <br>
    <span style="font-family: monospace;">make</span><br>
    <br>
    in the root DNest directory. This will create a shared library file
    <span style="font-family: monospace;">libdnest.so</span> and a
    static library <span style="font-family: monospace;">libdnest.a</span>
    in the current directory. If you like, feel free to copy these to
    some other location on your system, for example <span
      style="font-family: monospace;">/usr/local/lib</span>. It will
    also compile the examples in the <span style="font-family:
      monospace;">Examples/</span> directory, creating executable files
    that you can use to run the examples.<br style="color: red;">
    <br style="color: red;">
    <span style="color: rgb(0, 0, 153);">Note: On some systems, the
      Boost.Thread library files are named <span style="font-family:
        monospace;">libboost_thread-mt</span>, rather than <span
        style="font-family: monospace;">libboost_thread</span>. If you
      get linker errors about not being able to find <span
        style="font-family: monospace;">-lboost_thread</span>, and
      you're sure you've installed Boost correctly, this is probably the
      cause. To fix this problem, edit the <span style="font-family:
        monospace;">Makefile</span>s (the one from the root directory,
      and the one for each example) and replace <span
        style="font-family: monospace;">-lboost_thread</span> with <span
        style="font-family: monospace;">-lboost_thread-mt</span>.</span><br>
    <h3>Running the Examples</h3>
    Two examples are provided with DNest. I will now explain how DNest
    is used through the first example, <span style="font-style:
      italic;">SpikeSlab</span>.<br>
    <h4>Example 1: SpikeSlab</h4>
    The first example, called <span style="font-style: italic;">SpikeSlab</span>,
    is the demo problem from our <a
      href="http://arxiv.org/abs/0912.2380">paper</a>, and is a slight
    modification of one of the examples in <a
href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.117.5542&amp;rep=rep1&amp;type=pdf">John


      Skilling's Nested Sampling Paper</a>. It is a problem with 20
    unknown parameters, each with a uniform prior between -0.5 and 0.5.
    The priors for all of the parameters are independent. The likelihood
    function is a mixture of two Gaussians: one is a wide "slab" and the
    other is a narrow "spike". The slab is centered at (0, 0, ..., 0)
    with a width of 0.1 in each dimension. The spike is centered at
    (0.031, 0.031, ..., 0.031) and has a width of 0.01 in each
    dimension. This problem is challenging for all sampling algorithms
    that are not variants of Nested Sampling.<br>
    <br>
    To run DNest on the <span style="font-style: italic;">SpikeSlab</span>
    example, enter the <span style="font-family: monospace;">Examples/SpikeSlab</span>
    directory and run the executable:<br>
    <br>
    <code><span style="font-family: monospace;">cd Examples/SpikeSlab</span><br
        style="font-family: monospace;">
      <span style="font-family: monospace;">./SpikeSlab</span></code><br
      style="font-family: monospace;">
    <br>
    You should see a bunch of output that looks like this:<br>
    <samp><br>
      <span style="font-family: monospace;"># Running on 8 threads.</span><br
        style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 1 with logl
        = -51.66935275</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 2 with logl
        = -39.14905425</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 3 with logl
        = -30.58965377</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 4 with logl
        = -23.99380535</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 5 with logl
        = -18.36170088</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 6 with logl
        = -13.62243048</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Saving a sample. N = 1.</span><br
        style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 7 with logl
        = -9.477274449</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 8 with logl
        = -5.862379464</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 9 with logl
        = -2.525949929</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Creating level 10 with
        logl = 0.5035665194</span><br style="font-family: monospace;">
      <span style="font-family: monospace;"># Saving a sample. N = 2.</span><br
        style="font-family: monospace;">
    </samp><br>
    and so on. By default, this process will continue forever. At some
    point, you should kill it with Ctrl-C. Then, it is time to examine
    and process the output. The executable itself creates the following
    output files:<br>
    <br style="font-family: monospace;">
    <span style="font-family: monospace;">levels.txt</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">sample.txt</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">sample_info.txt</span><br
      style="font-family: monospace;">
    <br>
    Of these, <span style="font-family: monospace;">sample.txt</span>
    is the most important file, as it contains the samples. Each line
    corresponds to a sample, a point in the parameter space. However,
    the samples in <span style="font-family: monospace;">sample.txt</span>
    are <span style="font-style: italic;">not</span> posterior samples.
    Instead, they are samples from the mixture distribution that DNest
    actually explores. To actually get posterior samples, you need to
    run the post-processing script <span style="font-family:
      monospace;">showresults.py</span>. This script produces useful
    plots of the sort shown in the <a
      href="http://arxiv.org/abs/0912.2380">paper</a>, and also creates
    the following additional output files that will probably be of more
    interest to you:<br>
    <br>
    <span style="font-family: monospace;">weights.txt</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">posterior_sample.txt</span><span
      style="font-family: monospace;"></span><br style="font-family:
      monospace;">
    <br>
    The file <span style="font-family: monospace;">weights.txt</span>
    contains importance weights for the samples in <span
      style="font-family: monospace;">sample.txt</span>. Alternatively,
    if you are not used to dealing with non-equally-weighted samples,
    the file <span style="font-family: monospace;">posterior_sample.txt</span>
    is for you!<br>
    <br>
    <span style="color: rgb(0, 0, 153);">Note: You can also run <span
        style="font-family: monospace;">showresults.py</span> while the
      main process is still running. In fact, this is recommended in any
      non-trivial problem for monitoring the algorithm's progress. The
      only issue is that the main process may write to the output files
      while <span style="font-family: monospace;">showresults.py</span>
      is trying to load them. This may case an "ERROR: Size mismatch"
      message to be displayed. The workaround is to suspend the main
      process with Ctrl-Z, run <span style="font-family: monospace;">showresults.py</span>
      and then resume the main process with <span style="font-family:
        monospace;">fg</span>.</span><span style="font-weight: bold;"><br>
    </span>
    <h3>Implementing your own Models</h3>
    <a href="tutorial.html">Here</a> is a tutorial explaining how to
    implement "fitting a straight line" in DNest.<br>
    <h3>Tips and Tricks</h3>
    Click <a href="tips_and_tricks.html">here</a>.<br>
    <h3>Multithreading Disclaimer</h3>
    I am not an expert at multi-thread programming, which tends to be
    quite subtle. In fact, I learned it just so that I could parallelise
    DNest. I have made every effort to ensure that DNest does not
    produce any race conditions or other errors. For example, each
    thread gets its own random number generator (seeded with different
    values, of course), and each thread updates its own models. The
    occasional communication between threads is protected with mutexes
    (these allow you to create blocks of code that are guaranteed to be
    exectuted by only one thread at a time).<br>
    <br>
    However, I have read on the web that a lot of libraries, such as the
    C++ Standard Library, are not guaranteed to be thread-safe, and that
    this is implementation dependent. What this means, for example, is
    that if thread 1 is modifying some data in a C++ std::vector v1, and
    thread 2 is working on a <span style="font-style: italic;">completely

      different</span> vector v2, errors might still occur, maybe
    because the std::vector implementation might contain static
    variables.<br>
    <br>
    To check for threading errors, I have run DNest (compiled against
    recent versions of the GNU C++ library, GSL and Boost) through
    thread error checkers such as <a href="http://www.valgrind.org/">Valgrind</a>'s

    tools <span style="font-family: monospace;">drd</span> and <span
      style="font-family: monospace;">helgrind</span>, and they produced
    no errors*.<br>
    <br>
    <span style="font-family: monospace;">valgrind --tool=drd
      ./SpikeSlab</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">valgrind --tool=helgrind
      ./SpikeSlab</span><br style="font-family: monospace;">
    <span style="font-family: serif;"><br>
    </span><span style="font-family: serif;">*Apart from the following:
      1) <span style="font-family: monospace;">helgrind</span> produces
      false positives when using <span style="font-family: monospace;">boost::barrier</span>
      with older versions of Valgrind</span>. 2) Errors are reported
    when the program is terminated from <span style="font-family:
      monospace;">&lt;cstdlib&gt;</span>'s <span style="font-family:
      monospace;">exit(int)</span>. I doubt this is a real problem.<br>
    <br>
    If any of this worries you, you can always execute DNest in legacy
    mode, which will run the old serial version:<br>
    <br>
    <span style="font-family: monospace;">./SpikeSlab --legacy<br>
      <br>
    </span><span style="font-family: serif;">If you are an expert in
      multithreaded programming in C++, I would be interested in hearing
      from you.<br>
    </span>
    <h3>Other Recommended Samplers</h3>
    While DNest is a very effective sampler and works on a wide range of
    problems (including many problems with multi-modal posterior
    distributions or strong correlations), there are a few situations
    where I would recommend alternative methods. The primary situation
    in which DNest is not recommended is where the calls to the
    likelihood function are very slow, yet the number of parameters is
    small to moderate.<br>
    <br>
    For these problems, I would recommend <a
      href="http://github.com/dfm/emcee">emcee</a> in the case where
    strong correlations may be present but multimodality is unlikely, or
    <a href="http://ccpforge.cse.rl.ac.uk/gf/project/multinest/">MultiNest</a>
    if multimodality is expected or if the value of the evidence
    integral is required. These samplers also have the advantage of
    requring less programming from the user. For example, emcee only
    requires a likelihood function, whereas DNest requires a likelihood
    function, a function to generate random models from the prior, and a
    function for generating Metropolis-Hastings proposals.<br>
    <br>
  </body>
</html>
